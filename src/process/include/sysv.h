#ifndef TM_SYSV_H
#define TM_SYSV_H

// 管道和命名管道都是基于文件的系统的通信方式，而System V子系统中的进程通信是基于系统内核的。
// 共享内存、信号量和消息队列几种结构通常被称为IPC对象。
// 活动在内核中的IPC对象都有一个与之对应的唯一标识，通过此标识符就可以访问和引用IPC对象。

/**
 * 1. IPC 标识符
 * 在linux系统中，标识符是一个整数，每一个IPC对象的标识符在系统内部都是唯一的。在系统内部，通过
 * 传递IPC对象的标识符可以访问该对象。
 * 
 * 2. IPC 键
 * 键是一个IPC对象的外部标识，由程序员自己拟定，它主要用于多个进程都访问一个特定的IPC对象的情况。
 * 在创建一个IPC对象时，需要指定一个键值。如果该IPC键是公有的，那么系统中所有的进程通过权限检查
 * 后都能访问这个IPC对象；如果该键是私有的，通常把键值定义为0，该键的类型是系统定义的 key_t 类型。
 * 
 * 3. IPC 对象的属性
 * 
*/


/**
 * 信号是一个特殊变量，只允许对它进行等待（wait）和发送信号（signal）这两种操作。
 * 因为在Linux编程中，“等待”和“发送信号”都已具有特殊的含义，所以我们将用原先定义的符号来表示这两种操作。
□　P（信号量变量）：用于等待。
□　V（信号量变量）：用于发送信号。

最简单的信号量是只能取值0和1的变量，即二进制信号量。这也是信号量最常见的一种形式。可以取多个正整数值的信号量被称为通用信号量。


下面介绍三个常用函数:

1. 
int     semget(key_t key, int num_sems, int sem_flag);

semget函数的作用是创建一个新信号量或取得一个已有信号量的键。

第一个参数key是整数值，不相关的进程可以通过它访问同一个信号量。程序对所有信号量的访问都是间接的，
它先提供一个键，再由系统生成一个相应的信号量标识符。只有semget函数才直接使用信号量键，所有其他的
信号量函数都是使用由semget函数返回的信号量标识符。有一个特殊的信号量键值IPC_PRIVATE，它的作用
是创建一个只有创建者进程才可以访问的信号量，但这个键值很少有实际的用途。在创建新的信号量时，你需要
给键提供一个唯一的非零整数。

num_sems参数指定需要的信号量数目。它几乎总是取值为1。

sem_flags参数是一组标志，它与open函数的标志非常相似。它低端的9个比特是该信号量的权限，
其作用类似于文件的访问权限。此外，它们还可以和值IPC_CREAT做按位或操作，来创建一个新的、唯一的信号
量。如果该信号量已存在，它将返回一个错误。semget函数在成功时返回一个正数（非零）值，它就是其他信号
量函数将用到的信号量标识符。如果失败，则返回-1。


2．semop函数
semop函数用于改变信号量的值，它的定义如下所示：

int     semop(int sem_id, struct sembuf * sem_ops, size_t num_sem_ops);

第一个参数sem_id是由semget返回的信号量标识符。第二个参数sem_ops是指向一个结构数组的指针，每个数组
元素至少包含以下几个成员：
struct sembuf {
	unsigned short  sem_num;     
	short           sem_op; 
	short           sem_flg; 
};

第一个成员sem_num是信号量编号，除非你需要使用一组信号量，否则它的取值一般为0。sem_op成员的值是信号
量在一次操作中需要改变的数值（你可以用一个非0的数值来改变信号量的值）。通常只会用到两个值，一个是-1，
也就是P操作，它等待信号量变为可用；一个是+1，也就是V操作，它发送信号表示信号量现在已可用。
最后一个成员sem_flg通常被设置为SEM_UNDO。它将使得操作系统跟踪当前进程对这个信号量的修改情况，如果这
个进程在没有释放该信号量的情况下终止，操作系统将自动释放该进程持有的信号量。除非你对信号量的行为有特殊
的要求，否则应该养成设置sem_flg为SEM_UNDO的好习惯。如果决定使用一个非SEM_UNDO的值，那就一定要注意
保持设置的一致性，否则你很可能会搞不清楚内核是否会在进程退出时清理信号量。
semop调用的一切动作都是一次性完成的，这是为了避免出现因使用多个信号量而可能发生的竞争现象。

3．semctl函数
semctl函数用来直接控制信号量信息，它的定义如下所示：

int     semctl(int sem_id, int sem_num, int command, ...) ;

第一个参数sem_id是由semget返回的信号量标识符。sem_num参数是信号量编号，当需要用到成组的信号量时，就
要用到这个参数，它一般取值为0，表示这是第一个也是唯一的一个信号量。command参数是将要采取的动作。如果还
有第四个参数，它将会是一个union semun结构，根据X/OPEN规范的定义，它至少包含以下几个成员：

union semun {
	int             val;            
	struct semid_ds *buf;           
	unsigned short  *array;        
};
typedef union semun semun_t;

虽然X/Open规范中指出，semun联合结构必须由程序员自己定义，但大多数Linux版本会在某个头文件（一般是sem.h）
中给出该结构的定义。如果你发现确实需要自己来定义该结构，请查阅semctl的手册页，看手册中是否已给出了定义。
如果有，我们建议使用手册中给出的定义，即使它与这里给出的定义不一致也应该如此。
semctl函数中的command参数可以设置许多不同的值，但只有下面介绍的两个值最常用。
□　SETVAL：用来把信号量初始化为一个已知的值。这个值通过union semun中的val成员设置。其作用是在信号量第
一次使用之前对它进行设置。
□　IPC_RMID:用于删除一个已经无需继续使用的信号量标识符。
semctl函数将根据command参数的不同而返回不同的值。对于SETVAL和IPC_RMID，成功时返回0，失败时返回-1。
 * 
*/
int t_sigpv();
#endif //TM_SYSV_H